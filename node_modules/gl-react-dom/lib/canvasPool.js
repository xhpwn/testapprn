"use strict";

var Cache = require("./GLCanvasCache");
var pointerEventsProperty = require("./pointerEventsProperty");
var getContext = require("./getContext");

var maxSizePool = 20;
var pool = [];

function setSize(size) {
  maxSizePool = size;
  pool.splice(size).forEach(function (p) {
    return p.dispose(true);
  });
}

function clear() {
  pool.splice(0).forEach(function (p) {
    return p.dispose(true);
  });
}

function create(parentNode) {
  var poolObject = void 0;

  if (pool.length > 0) {
    // reuse most recently used canvas
    poolObject = pool.splice(pool.length - 1)[0];
  } else {
    // create a new canvas / context
    var canvas = document.createElement("canvas");
    canvas.style[pointerEventsProperty] = "none";
    canvas.style.width = "100%";
    canvas.style.height = "100%";

    var opts = {};
    var gl = getContext(canvas, opts);

    if (!gl) return null;

    var dispose = function dispose(dontReuse) {
      if (canvas.parentNode) {
        canvas.parentNode.removeChild(canvas);
      }
      var reachPoolLimit = pool.length >= maxSizePool;
      if (reachPoolLimit) {
        console.warn( // eslint-disable-line no-console
        "gl-react-dom: canvasPool of size " + maxSizePool + " reached, you might want to increase pool size, use less concurrent WebGL Canvases or consider using gl-react-dom-static-container library");
      }
      if (!dontReuse && !reachPoolLimit && pool.indexOf(poolObject) === -1) {
        pool.push(poolObject);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      } else {
        poolObject.cache.dispose();
      }
    };

    var _w = -1,
        _h = -1,
        _s = -1;
    var resize = function resize(w, h, scale) {
      var scaleChanged = scale !== _s;
      if (scaleChanged) {
        _s = scale;
      }
      if (w !== _w || scaleChanged) {
        _w = w;
        canvas.width = scale * w;
      }
      if (h !== _h || scaleChanged) {
        _h = h;
        canvas.height = scale * h;
      }
    };

    poolObject = {
      canvas: canvas,
      gl: gl,
      dispose: dispose,
      resize: resize,
      cache: new Cache(gl)
    };
  }

  parentNode.appendChild(poolObject.canvas);

  return poolObject;
}

module.exports = {
  create: create,
  clear: clear,
  setSize: setSize
};
//# sourceMappingURL=canvasPool.js.map